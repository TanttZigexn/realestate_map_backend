services:
  db:
    image: postgis/postgis:16-3.4-alpine
    container_name: rental_search_api_db_prod
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-rental_search_api}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB:-rental_search_api_production}
      POSTGRES_INITDB_ARGS: "-E UTF8 --locale=en_US.UTF-8"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-rental_search_api}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    restart: unless-stopped
    networks:
      - backend
    # Don't expose port in production - only accessible from backend network

  web:
    build:
      context: .
      dockerfile: Dockerfile
      args:
        RUBY_VERSION: 3.3.4
        RAILS_ENV: production
    container_name: rental_search_api_web_prod
    command: bash -c "rm -f tmp/pids/server.pid && bundle exec rails db:prepare && bundle exec rails server -b 0.0.0.0 -p 3000"
    environment:
      RAILS_ENV: production
      RACK_ENV: production
      NODE_ENV: production

      # Database configuration
      DATABASE_URL: postgresql://${POSTGRES_USER:-rental_search_api}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB:-rental_search_api_production}
      DATABASE_HOST: db
      DATABASE_USER: ${POSTGRES_USER:-rental_search_api}
      DATABASE_PASSWORD: ${POSTGRES_PASSWORD}
      DATABASE_PORT: 5432

      # Rails secrets
      RAILS_MASTER_KEY: ${RAILS_MASTER_KEY}
      SECRET_KEY_BASE: ${SECRET_KEY_BASE}

      # Application settings
      RAILS_MAX_THREADS: ${RAILS_MAX_THREADS:-10}
      WEB_CONCURRENCY: ${WEB_CONCURRENCY:-2}
      RAILS_LOG_LEVEL: ${RAILS_LOG_LEVEL:-info}
      RAILS_SERVE_STATIC_FILES: "true"

      # API keys
      MAPBOX_ACCESS_TOKEN: ${MAPBOX_ACCESS_TOKEN}

      # CORS settings
      ALLOWED_ORIGINS: ${ALLOWED_ORIGINS:-*}

      # Application URL
      APP_HOST: ${APP_HOST:-localhost}
      APP_PORT: ${APP_PORT:-3000}
      RAILS_FORCE_SSL: ${RAILS_FORCE_SSL:-false}

    depends_on:
      db:
        condition: service_healthy

    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/up"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

    restart: unless-stopped

    networks:
      - backend
      - frontend

    # Don't mount source code in production
    # Code is baked into the Docker image
    volumes:
      - storage_data:/rails/storage
      - log_data:/rails/log

    stdin_open: false
    tty: false

  nginx:
    image: nginx:alpine
    container_name: rental_search_api_nginx_prod
    ports:
      - "${NGINX_PORT:-80}:80"
      - "${NGINX_SSL_PORT:-443}:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/conf.d:/etc/nginx/conf.d:ro
      - ./public:/usr/share/nginx/html:ro
      - nginx_logs:/var/log/nginx
      # Uncomment for SSL certificates
      # - ./nginx/ssl:/etc/nginx/ssl:ro
      # - ./certbot/conf:/etc/letsencrypt:ro
      # - ./certbot/www:/var/www/certbot:ro
    depends_on:
      web:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - frontend
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Optional: SSL certificate management with Let's Encrypt
  # certbot:
  #   image: certbot/certbot
  #   container_name: rental_search_api_certbot
  #   volumes:
  #     - ./certbot/conf:/etc/letsencrypt
  #     - ./certbot/www:/var/www/certbot
  #   entrypoint: "/bin/sh -c 'trap exit TERM; while :; do certbot renew; sleep 12h & wait $${!}; done;'"
  #   restart: unless-stopped

  # Optional: Redis for caching (alternative to solid_cache)
  # redis:
  #   image: redis:7-alpine
  #   container_name: rental_search_api_redis_prod
  #   command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}
  #   volumes:
  #     - redis_data:/data
  #   healthcheck:
  #     test: ["CMD", "redis-cli", "--raw", "incr", "ping"]
  #     interval: 10s
  #     timeout: 5s
  #     retries: 5
  #   restart: unless-stopped
  #   networks:
  #     - backend

networks:
  backend:
    driver: bridge
    internal: true  # Backend network not accessible from outside
  frontend:
    driver: bridge

volumes:
  postgres_data:
    driver: local
  storage_data:
    driver: local
  log_data:
    driver: local
  nginx_logs:
    driver: local
  # redis_data:
  #   driver: local

